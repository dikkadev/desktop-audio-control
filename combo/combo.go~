package combo

import (
	"desktop-audio-ctrl/rotary"
	screenlib "desktop-audio-ctrl/screen"
	"image/color"
	"machine"
	"math"
	"math/rand/v2"

	"tinygo.org/x/tinyfont"
	"tinygo.org/x/tinyfont/freemono"
)

var (
	drawColor = color.RGBA{255, 255, 255, 255}
)

type Combo struct {
	screen  *screenlib.Screen
	encoder *rotary.Encoder

	state int
	name  string
}

func NewCombo(i2c *machine.I2C, screenChannel uint8, encoderAddress uint16, name string) *Combo {
	c := Combo{
		screen:  screenlib.NewScreen(screenChannel),
		encoder: rotary.NewEncoder(i2c, encoderAddress),
		name:    name,
		state:   rand.IntN(101),
	}
	return &c
}

func (c *Combo) Update() bool {
	state, err := c.encoder.GetState()
	if err != nil {
		panic(err)
	}
	switch state {
	case rotary.RotaryIdle:
		return false
	case rotary.RotaryCW:
		println("Clockwise")
		c.state++
	case rotary.RotaryCCW:
		println("Counter Clockwise")
		c.state--
	case rotary.BtnClick:
		println("Click")
		c.state = 0
	}

	if c.state < 0 {
		c.state = 0
	}
	if c.state > 100 {
		c.state = 100
	}
	return true

}

const TEXT_HEIGHT = 9

func (c *Combo) Draw() {
	c.screen.Activate()

	centerText(c.name, &freemono.Regular9pt7b, TEXT_HEIGHT)
	bar(c.state)

	screenlib.Display.Display()
}

func centerText(text string, font *tinyfont.Font, x int) {
	_, outBox := tinyfont.LineWidth(font, text)
	y := 64 - ((64 - outBox) / 2)
	tinyfont.WriteLineRotated(screenlib.Display, font, int16(x), int16(y), text, drawColor, tinyfont.ROTATION_270)
}

func bar(fill int) {
	var leftX int16 = 17
	var rightX int16 = 118
	var topY int16 = 17
	var bottomY int16 = 47
	var radius int16 = 12

	// Draw vertical sides
	for y := topY + radius; y <= bottomY-radius; y++ {
		screenlib.Display.SetPixel(leftX, y, drawColor)
		screenlib.Display.SetPixel(rightX, y, drawColor)
	}

	// Draw horizontal sides
	for x := leftX + radius; x <= rightX-radius; x++ {
		screenlib.Display.SetPixel(x, topY, drawColor)
		screenlib.Display.SetPixel(x, bottomY, drawColor)
	}

	// Draw corners
	drawCorner(leftX+radius, topY+radius, radius, 2)     // Top-left corner
	drawCorner(rightX-radius, topY+radius, radius, 1)    // Top-right corner
	drawCorner(leftX+radius, bottomY-radius, radius, 3)  // Bottom-left corner
	drawCorner(rightX-radius, bottomY-radius, radius, 4) // Bottom-right corner

	// Fill the bar according to 'fill' value
	if fill > 0 {
		startX := rightX - 1 - int16(fill-1)
		if startX < leftX+1 {
			startX = leftX + 1
		}
		endX := rightX - 1
		for x := startX; x <= endX; x++ {
			for y := topY + 1; y <= bottomY-1; y++ {
				screenlib.Display.SetPixel(x, y, drawColor)
			}
		}
	}
}

// Helper function to draw rounded corners
func drawCorner(centerX, centerY, radius int16, quadrant int) {
	for dx := int16(0); dx <= radius; dx++ {
		dy := int16(math.Round(math.Sqrt(float64(radius*radius - dx*dx))))
		switch quadrant {
		case 1: // Top-right corner
			screenlib.Display.SetPixel(centerX+dx, centerY-dy, drawColor)
			screenlib.Display.SetPixel(centerX+dy, centerY-dx, drawColor)
		case 2: // Top-left corner
			screenlib.Display.SetPixel(centerX-dx, centerY-dy, drawColor)
			screenlib.Display.SetPixel(centerX-dy, centerY-dx, drawColor)
		case 3: // Bottom-left corner
			screenlib.Display.SetPixel(centerX-dx, centerY+dy, drawColor)
			screenlib.Display.SetPixel(centerX-dy, centerY+dx, drawColor)
		case 4: // Bottom-right corner
			screenlib.Display.SetPixel(centerX+dx, centerY+dy, drawColor)
			screenlib.Display.SetPixel(centerX+dy, centerY+dx, drawColor)
		}
	}
}
